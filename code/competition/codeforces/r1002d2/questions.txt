An array is called good if for any element x that appears in this array, it holds that x appears at least twice in this array. For example, the arrays [1,2,1,1,2], [3,3], and [1,2,4,1,2,4] are good, while the arrays [1], [1,2,1], and [2,3,4,4]

are not good.

Milya has two good arrays a
and b of length n. She can rearrange the elements in array a in any way. After that, she obtains an array c of length n, where ci=ai+bi (1≤i≤n

).

Determine whether Milya can rearrange the elements in array a
such that there are at least 3 distinct elements in array c

.
Input

Each test consists of multiple test cases. The first line contains a single integer t
(1≤t≤1000

) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n
(3≤n≤50) — the length of the arrays a and b

.

The second line of each test case contains n
integers a1,a2,…,an (1≤ai≤109) — the elements of the array a

.

The third line of each test case contains n
integers b1,b2,…,bn (1≤bi≤109) — the elements of the array b

.
Output

For each test case, output «
YES» (without quotes) if it is possible to obtain at least 3 distinct elements in array c, and «NO»

otherwise.

You can output each letter in any case (for example, «
YES», «Yes», «yes», «yEs» will be recognized as a positive answer).










You are given an array a of length n and an even integer k (2≤k≤n). You need to split the array a into exactly k non-empty subarrays† such that each element of the array a

belongs to exactly one subarray.

Next, all subarrays with even indices (second, fourth, …
, k-th) are concatenated into a single array b. After that, 0 is added to the end of the array b

.

The cost of the array b
is defined as the minimum index i such that bi≠i. For example, the cost of the array b=[1,2,4,5,0] is 3, since b1=1, b2=2, and b3≠3. Determine the minimum cost of the array b that can be obtained with an optimal partitioning of the array a

into subarrays.

†
An array x is a subarray of an array y if x can be obtained from y

by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.
Input

Each test consists of multiple test cases. The first line contains a single integer t
(1≤t≤104

) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n
and k (2≤k≤n≤2⋅105, k is even) — the length of the array a

and the number of subarrays.

The second line of each test case contains n
integers a1,a2,…,an (1≤ai≤109) — the elements of the array a

.

It is guaranteed that the sum of n
over all test cases does not exceed 2⋅105

.
Output

For each test case, output a single integer — the minimum cost of the array b
that can be obtained.












Nikyr has started working as a queue manager at the company "Black Contour." He needs to choose the order of servicing customers. There are a total of n queues, each initially containing 0 people. In each of the next n

moments of time, there are two sequential events:

    New customers arrive in all queues. More formally, at the j

-th moment of time, the number of people in the i-th queue increases by a positive integer ai,j
.
Nikyr chooses exactly one of the n
queues to be served at that moment in time. The number of customers in this queue becomes 0

    .

Let the number of people in the i
-th queue after all events be xi. Nikyr wants MEX† of the collection x1,x2,…,xn

to be as large as possible. Help him determine the maximum value he can achieve with an optimal order of servicing the queues.

†
The minimum excluded (MEX) of a collection of integers c1,c2,…,ck is defined as the smallest non-negative integer y which does not occur in the collection c

.

For example:

    MEX([2,2,1])=0

, since 0
does not belong to the array.
MEX([3,1,0,1])=2
, since 0 and 1 belong to the array, but 2
does not.
MEX([0,3,1,2])=4
, since 0, 1, 2, and 3 belong to the array, but 4

    does not.

Input

Each test consists of multiple test cases. The first line contains a single integer t
(1≤t≤2⋅104

) — the number of test cases. The description of the test cases follows.

The first line of each test case contains a single integer n
(1≤n≤300

) — the number of queues and moments of time.

The i
-th of the next n lines contains n integers ai,1,ai,2,…,ai,n (1≤ai,j≤109) — the number of new customers in the i

-th queue at each moment of time.

It is guaranteed that the sum of n2
over all test cases does not exceed 2⋅105

.
Output

For each test case, output a single integer — the maximum value of MEX([x1,x2,…,xn])
that can be achieved.















You are given two connected undirected graphs with the same number of vertices. In both graphs, there is a token located at some vertex. In the first graph, the token is initially at vertex s1, and in the second graph, the token is initially at vertex s2

. The following operation is repeated an infinite number of times:

    Let the token currently be at vertex v1

in the first graph and at vertex v2
in the second graph.
A vertex u1
, adjacent to v1
, is chosen in the first graph.
A vertex u2
, adjacent to v2
, is chosen in the second graph.
The tokens are moved to the chosen vertices: in the first graph, the token moves from v1
to u1, and in the second graph, from v2 to u2
.
The cost of such an operation is equal to |u1−u2|

    .

Determine the minimum possible total cost of all operations or report that this value will be infinitely large.
Input

Each test consists of multiple test cases. The first line contains one integer t
(1≤t≤500

) — the number of test cases. The description of the test cases follows.

The first line of each test case contains three integers n
, s1, and s2 (2≤n≤1000, 1≤s1,s2≤n

) — the number of vertices in each graph, the number of the vertex in the first graph where the token is initially located, and the number of the vertex in the second graph where the token is initially located.

The second line of each test case contains one integer m1
(1≤m1≤1000

) — the number of edges in the first graph.

The i
-th of the following m1 lines contains two integers ai and bi (1≤ai,bi≤n, ai≠bi) — the numbers of the endpoints of the i

-th edge in the first graph.

The next line of each test case contains one integer m2
(1≤m2≤1000

) — the number of edges in the second graph.

The j
-th of the following m2 lines contains two integers cj and dj (1≤cj,dj≤n, cj≠dj) — the numbers of the endpoints of the j

-th edge in the second graph.

It is guaranteed that the sum of n
, the sum of m1, and the sum of m2 over all test cases do not exceed 1000

.

It is guaranteed that both graphs are connected.
Output

For each test case, output one integer — the minimum total cost of all operations or −1
, if this value will be infinitely large.






This is the easy version of the problem. The difference between the versions is that in this version you only need to find the minimum number of operations. You can hack only if you solved all versions of this problem.

You are given n
arrays, each of which has a length of m. Let the j-th element of the i-th array be denoted as ai,j. It is guaranteed that all ai,j

are pairwise distinct. In one operation, you can do the following:

    Choose some integer i

(1≤i≤n) and an integer x (1≤x≤2⋅n⋅m
).
For all integers k
from i to n in increasing order, do the following:

    Add the element x

to the beginning of the k
-th array.

Assign x
the value of the last element in the k
-th array.

Remove the last element from the k

        -th array.

In other words, you can insert an element at the beginning of any array, after which all elements in this and all following arrays are shifted by one to the right. The last element of the last array is removed.

You are also given a description of the arrays that need to be obtained after all operations. That is, after performing the operations, the j
-th element of the i-th array should be equal to bi,j. It is guaranteed that all bi,j

are pairwise distinct.

Determine the minimum number of operations that need to be performed to obtain the desired arrays.
Input

Each test consists of multiple test cases. The first line contains a single integer t
(1≤t≤104

) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n
and m (1≤n,m≤3⋅105

) — the number of arrays and the number of elements in each array.

The i
-th of the following n lines contains m integers ai,1,ai,2,…,ai,m (1≤ai,j≤2⋅n⋅m) — the elements of the i-th original array. It is guaranteed that all ai,j

are pairwise distinct.

The i
-th of the following n lines contains m integers bi,1,bi,2,…,bi,m (1≤bi,j≤2⋅n⋅m) — the elements of the i-th final array. It is guaranteed that all bi,j

are pairwise distinct.

It is guaranteed that the sum of n⋅m
over all test cases does not exceed 3⋅105

.
Output

For each test case, output a single integer — the minimum number of operations that need to be performed.











This is the hard version of the problem. The difference between the versions is that in this version you need to output all the operations that need to be performed. You can hack only if you solved all versions of this problem.

You are given n
arrays, each of which has a length of m. Let the j-th element of the i-th array be denoted as ai,j. It is guaranteed that all ai,j

are pairwise distinct. In one operation, you can do the following:

    Choose some integer i

(1≤i≤n) and an integer x (1≤x≤2⋅n⋅m
).
For all integers k
from i to n in increasing order, do the following:

    Add the element x

to the beginning of the k
-th array.

Assign x
the value of the last element in the k
-th array.

Remove the last element from the k

        -th array.

In other words, you can insert an element at the beginning of any array, after which all elements in this and all following arrays are shifted by one to the right. The last element of the last array is removed.

You are also given a description of the arrays that need to be obtained after all operations. That is, after performing the operations, the j
-th element of the i-th array should be equal to bi,j. It is guaranteed that all bi,j

are pairwise distinct.

Determine the minimum number of operations that need to be performed to obtain the desired arrays, and also output the sequence of all operations itself.
Input

Each test consists of multiple test cases. The first line contains a single integer t
(1≤t≤104

) — the number of test cases. The description of the test cases follows.

The first line of each test case contains two integers n
and m (1≤n,m≤3⋅105

) — the number of arrays and the number of elements in each array.

The i
-th of the following n lines contains m integers ai,1,ai,2,…,ai,m (1≤ai,j≤2⋅n⋅m) — the elements of the i-th original array. It is guaranteed that all ai,j

are pairwise distinct.

The i
-th of the following n lines contains m integers bi,1,bi,2,…,bi,m (1≤bi,j≤2⋅n⋅m) — the elements of the i-th final array. It is guaranteed that all bi,j

are pairwise distinct.

It is guaranteed that the sum of n⋅m
over all test cases does not exceed 3⋅105

.
Output

For each test case, output a single integer — the minimum number of operations that need to be performed.

Next, for each operation output two integers i
and x (1≤i≤n, 1≤x≤2⋅n⋅m

) — the index of the array where the element is inserted and the value of the element, respectively.

If there are multiple possible sequences with the minimum number of operations, output any of them.
Example
